import {Matrix4, Vector3} from "three";const v = new Vector3();const m = new Matrix4();let c = -1;const v_dir = new Vector3(0,0,1);const v_origin = new Vector3(0,0,0);const tmp = new Vector3();const getNoteRay= (world,beat,id_on_beat)=>{    v_origin.set(0,0,0);    let matrix =world.geometry.level.instancedMatrices[id_on_beat].clone();    v_dir.set(0,1,0);    //apply transformation so beam is starting at out position.    let transformed_dir = v_dir.applyMatrix4(matrix);    tmp.setFromMatrixPosition(matrix);    tmp.add(transformed_dir.multiplyScalar(-0.08));    matrix.setPosition(tmp);        const c_u = world.geometry.level.offsets[beat];    world.Curve.getTBNAt(c_u,m);    v_dir.set(0,0,1);    transformed_dir = v_dir.applyMatrix4(matrix);    const transformed_origin = v_origin.applyMatrix4(matrix);    transformed_origin.applyMatrix4(m);    transformed_dir.applyMatrix4(m);    transformed_dir.sub(transformed_origin);    transformed_dir.normalize();    return {origin: transformed_origin, direction: transformed_dir};}const raySphereIntersection =(origin,direction,center,radius)=>{    tmp.subVectors(origin,center);    const a = direction.dot(direction);    const b = 2.0 * tmp.dot(direction);    const c = tmp.dot(tmp) - radius*radius;    const discriminant = b*b - 4*a*c;    if(discriminant < 0){        return -1.0;    }    else{        return (-b - Math.sqrt(discriminant)) / (2.0*a);        }}export const musicInteractionSystem = (world) => {    let procceedInteraction = (note,beat)=>{        const id_on_beat = note.id_on_beat;        const instrument = note.instrument;        const effect = note.effect;                //test        const ray =  getNoteRay(world,beat% world.GlobalParameters.barSize,id_on_beat);                const d = raySphereIntersection(ray.origin,ray.direction,world.camera.position,0.2);                if (d !==-1 && d<1){            world.AudioSystem.playInstrumentAt(note,d);            note.played_at = beat;        }    /*    if (note.geometry === undefined) {            note.geometry = true;            world.scene.add(new ArrowHelper(transformed_dir, transformed_origin, 0.7, 0xff0000));        }*/                //calculate position and direction using CURVE tangents and normals binormals.        //cast a ray and look for interaction with camera sphere        // if (interaction) get distance        //  pitch instrument with distance, play instrument    }  //  for (let r =0; r< 1;r++)    //    procceedInteraction(r);    const current_cell = world.Curve.getCurrentCell(1);    //current_cell = 100;    //melody size is 16 bars, or 2 of eight.    //100%16 = 4. loop through 4 beat.    //100%            /*const beat = current_cell % world.GlobalParameters.barSize;    world.AudioSystem.melody[beat].instances.forEach((note)=>{        procceedInteraction(note,current_cell);    });*/        //must find beat to match current cell.    const forward_beat = (current_cell) % world.GlobalParameters.barSize;        world.AudioSystem.melody[forward_beat].instances.forEach((note)=>{        if (note.played_at !== current_cell) {            procceedInteraction(note, current_cell);        }    });    //const prev_beat = (world.Curve.getCurrentNormalizedCell(-1)) % world.GlobalParameters.barSize;    //console.log(prev_beat)    //world.AudioSystem.melody[prev_beat].instances.forEach((note)=>{    //    procceedInteraction(note,world.Curve.getCurrentNormalizedCell(-1));    //});            return world}